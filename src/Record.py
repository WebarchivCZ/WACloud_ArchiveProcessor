#!/usr/bin/python
# coding: utf-8

"""..module:: archiveprocessor.Record.

..moduleauthor:: Jan Lehecka <jlehecka@ntis.zcu.cz>
"""
from typing import Union, Dict, Any
from cgi import parse_header
import pprint
import uuid
import re

from surt import surt
from warcio.recordloader import ArcWarcRecord

from BaseAlgorithms import BaseAlgorithm
from utils import bytes_to_base64, base64_to_bytes, warc_name_to_harvest_info
from metadata import (
    ID,
    CONTENT,
    URLKEY,
    URL,
    MIMETYPE,
    RESPONSECODE,
    REDIRECT,
    WARCFILENAME,
    RECHEADERS,
    HTTPHEADERS,
    REFERSTO,
    HARVESTID,
    EXTRA,
    WRH_META_MAP,
    INT_FIELDS
)


class Record(BaseAlgorithm):
    """Representation of one WARC record.

    This module deals with all necessary metadata extraction and content
    decoding.

    Data and metadata are stored in dictionary `self.data`, but are also
    accessible via `self[key]`.

    """

    def _init(
          self,
          obj: Union[
            Dict[str, Any],
            ArcWarcRecord,
            ],
          warc_file_name=None
          ) -> None:
        """Class constructor.

        Args:
            obj: Object to initialize the record from, supported object are:
                - dict,
                - HBase main table row,
                - ArcWarcRecord (object from warcio python package).
            warc_file_name: The name of the source WARC file (used only when
                initializing from ArcWarcRecord).

        """
        self.data = {}
        if isinstance(obj, dict):
            self.init_from_dict(obj)
        # TODO: init from HBase main table row (is it type dict too?)
        elif isinstance(obj, ArcWarcRecord):
            self.init_from_ArcWarcRecord(obj, warc_file_name)
        else:
            self.logger.error(f'Unsupported data type: {type(obj)}')
        self.is_revisit = self[REFERSTO] not in ["", None]
        if EXTRA not in self.data:
            self.data[EXTRA] = []

    def init_from_dict(self, data: Dict[str, Any]) -> None:
        """Initialize record from a dictionary.

        Args:
            data: Key-value pairs with data.

        """
        self.data = data

    def init_from_ArcWarcRecord(
          self,
          AWRec: ArcWarcRecord,
          warc_file_name: str,
          ) -> None:
        """Initialize record from an ArcWarcRecord (generated by warcio).

        Args:
            AWRec: ArcWarcRecord object.
            warc_file_name: The name of the source WARC file.

        """
        if AWRec.http_headers is None:
            self[HTTPHEADERS] = {}
            self[RESPONSECODE] = ""
        else:
            self[HTTPHEADERS] = dict(AWRec.http_headers.headers)
            self[RESPONSECODE] = AWRec.http_headers.get_statuscode()
        if AWRec.rec_headers is None:
            self[RECHEADERS] = {}
        else:
            self[RECHEADERS] = dict(AWRec.rec_headers.headers)

        ctype = self[HTTPHEADERS].get("Content-Type", "")
        self[MIMETYPE], params = parse_header(ctype)
        self[CONTENT] = bytes_to_base64(AWRec.content_stream().read())
        self[WARCFILENAME] = warc_file_name
        self.map_rec_headers()
        self.refine_id()
        self.refine_refersto()
        self.refine_filename()
        self.extract_urlkey()
        self.extract_harvest_ID()
        self.check_int_fileds()
        self.find_redirect()

    def map_rec_headers(self) -> None:
        """Map metadata from WARC record headers."""
        rh = self[RECHEADERS] or {}
        for wrhkey, field in WRH_META_MAP.items():
            val = rh.get(wrhkey, None)
            if val is not None:
                self[field] = val

    def extract_urlkey(self) -> None:
        """Canonicalize URL using SURT package."""
        self[URLKEY] = surt(self[URL], surt=False)

    def refine_filename(self) -> None:
        """Refine file name."""
        if self[WARCFILENAME]:
            self[WARCFILENAME] = re.sub(r'^file\:', '', self[WARCFILENAME])

    def extract_harvest_ID(self) -> None:
        """Extract harvest ID (i.e. the name) from the WARC filename."""
        info = warc_name_to_harvest_info(self[WARCFILENAME])
        if not info:
            self.logger.warning(
                f'Failed to extract harvest ID from WARC '
                f'"{self[WARCFILENAME]}".'
            )
        self[HARVESTID] = info.get('name', '')

    def refine_id(self) -> None:
        """Refine ID or generate new one."""
        if self[ID]:
            self[ID] = self[ID].strip('<>')
        else:
            self[ID] = f'urn:uuid:{uuid.uuid4()}'
            self.logger.warning(
                f'No ID found in the record with URL {self[URL]} , generated '
                f'new one: {self[ID]}'
            )

    def refine_refersto(self) -> None:
        """Refine reference ID for revisit records."""
        if self[REFERSTO]:
            self[REFERSTO] = self[REFERSTO].strip('<>')

    def find_redirect(self) -> None:
        """Find target URI of redirection and check correct status code."""
        redirect = (self[HTTPHEADERS] or {}).get('Location')
        if redirect:
            status = self[RESPONSECODE] or ''
            if re.match(r'^(3\d\d|201|202)$', status):
                self[REDIRECT] = redirect
            else:
                self.logger.debug(
                    f'Found Location field "{redirect}", but with wrong '
                    f'status code ({status}) (URL {self[URL]} and '
                    f'ID="{self[ID]}")'
                )

    def check_int_fileds(self) -> None:
        """Assure integer fields contain int types."""
        for field in INT_FIELDS:
            val = self[field]
            if val is None:
                continue
            if isinstance(val, int):
                continue
            if isinstance(val, float):
                self[field] = int(val)
            elif isinstance(val, str) and val.isdigit():
                self[field] = int(val)
            else:
                self.logger.error(
                    f'Error while converting field {field} into integer '
                    f'(value="{val}") (record with URL {self[URL]} and '
                    f'id="{self[ID]}")'
                )
                del self[field]

    def get_content_bytes(self) -> bytes:
        """Return record content as a sequence of bytes.

        The content is stored as base64 unicode string.

        Returns:
            content: The byte content (payload) of the record.

        """
        content_base64 = self[CONTENT] or ''
        try:
            content = base64_to_bytes(content_base64)
        except Exception as e:
            self.logger.error(
                f'Error while decoding content: ({e}) (record with URL '
                f'{self[URL]} and id="{self[ID]}")'
            )
            return b''
        return content

    def __getitem__(self, key: str) -> Any:
        """Get value for given key."""
        return self.data.get(key, None)

    def __setitem__(self, key: str, value: Any) -> None:
        """Set value for given key."""
        self.data[key] = value

    def __delitem__(self, key: str) -> None:
        """Delete key-value pair."""
        del self.data[key]

    def __str__(self) -> str:
        """Pretty-print of record data except for base64-encoded content."""
        return pprint.pformat(
            dict((k, v) for k, v in self.data.items() if k != CONTENT),
        )
